## Node package manager
Originally using yarn, but that was yarn 1. Seems like yarn is moving in a proprietary direction and no longer shadows NPM.

pnpm looks promising, but npm8+ has workspaces and matches yarn classic on behavior/speed, it appears.

## Colocation
Should python and TSX files be mixed? Why aren't templates like WidgetList.tsx
and templates.py and views.py not all mixed together?

Why continue with the concept with client and server?

## Proxy types
This is currently used only for form and form sets, but could be used for
everything and get rid of the registration system.

So:

```
@proxy(models.Field)
class ModelFieldType:
    @classmethod
    def get_json_schema(
        Proxy: Type["ModelFieldType"],
        Type: Type[models.Field],
        definitions: Definitions,
    ) -> "Thing":
        ...
```

This can handle the built-in fields. Custom fields can then just use:


```
@proxy(CustomField)
class CustomFieldType:
    ...
```

To specify how to create the schema and serialize.

Since we want to use DRF's ClassLookupDict, you can actually even override
serialization for built-in types. So the ModelFieldType handles the default for
say, `DecimalField`. But you can do a custom one by registering a more specific
type:

```
@proxy(DecimalField)
class CustomDecimalFieldType
    ...

```

This will get picked up before the basic handler.


## Rendering approaches


### Communicate / stdin

Breaks with large data.
```
    process = subprocess.Popen(
        ["node", "./static/dist/server.js"],
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
    )
    print(data)
    process_response, error = process.communicate(data.encode())
```


### Threading
https://stackoverflow.com/a/14026178
Still breaks with large enough data.
```
    process = subprocess.Popen(
        ["node", "./static/dist/server.js"],
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
    )
    process_response = ""
    error = None

    def writer() -> None:
        for char in data:
            process.stdin.write(char.encode())
        process.stdin.close()

    thread = threading.Thread(target=writer)
    thread.start()
    for line in process.stdout:
        process_response += line.decode()
    thread.join()
    process.wait()
    assert False
```

### File based
This works, but seems kind of dirty and maybe problematic on docker images that
then grow in size.
```
    with tempfile.TemporaryFile() as buffer:
        buffer.write(data.encode())
        buffer.flush()
        buffer.seek(0)

        process = subprocess.Popen(
            ["node", "./static/dist/server.js"],
            stdout=subprocess.PIPE,
            stdin=buffer,
        )
        process_response, error = process.communicate()
```
