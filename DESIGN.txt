## Useful commands
Destroy every app:
fly apps list --json | jq ".[].Name" -r | xargs -L 1 fly apps destroy --yes

## General TODO
- [ ] Trying to render a nonexistent tsx template crashes the server. it should
error out gracefully.
- [ ] Figure out static generation. Do we put it inside the the reactivated app
  package? This is kind of magical but would work. Or maybe inside client/generated/.
- [ ] pyproject.toml consolidation.
- [ ] Do we want tests.py or pytests.py?

## Invocation / installation
Currently using create-django-app with NPM, but that itself really just wraps nix and checks for nix-shell.
And the user will have to have installed nix anyway already. Why not just use nix directly?

Something like:

```
nix-shell -E "import (builtins.fetchurl https://reactivated.io/install/)"
```

## Conventions
* Do we want to encourage CreateFooForm or CreateForm? While Django tends to promote
FooModelAdmin, etc, a lot of it is redundant. Static typing makes everything obvious,
more over, we encourage namespace imports like forms.CreateFoo, why repeat Form?
We don't do FooTemplate, we do templates.Foo. And so on.

## Postgres
Having local development work on postgres is *essential*. Rather than sqlite.

The current system of tying it to venv works reasonably well, though sockets
unfortunately need to go in /tmp to avoid length limits.

Also, theoretically if you remove .venv without stopping pg_ctl, you will get zombie
processes. Not the end of the world but can result in a lot of postgres servers
running.

Troubleshooting postgres: sometimes it seems to crash if you delete and recreate
the project, maybe related to the zombie processs still running, then giving up.

Deleting the .venv and exiting nix-shell and re-running recreates it.

## Node package manager
Originally using yarn, but that was yarn 1. Seems like yarn is moving in a proprietary direction and no longer shadows NPM.

pnpm looks promising, but npm8+ has workspaces and matches yarn classic on behavior/speed, it appears.

## Colocation
Should python and TSX files be mixed? Why aren't templates like WidgetList.tsx
and templates.py and views.py not all mixed together?

Why continue with the concept with client and server?

## Proxy types
This is currently used only for form and form sets, but could be used for
everything and get rid of the registration system.

So:

```
@proxy(models.Field)
class ModelFieldType:
    @classmethod
    def get_json_schema(
        Proxy: Type["ModelFieldType"],
        Type: Type[models.Field],
        definitions: Definitions,
    ) -> "Thing":
        ...
```

This can handle the built-in fields. Custom fields can then just use:


```
@proxy(CustomField)
class CustomFieldType:
    ...
```

To specify how to create the schema and serialize.

Since we want to use DRF's ClassLookupDict, you can actually even override
serialization for built-in types. So the ModelFieldType handles the default for
say, `DecimalField`. But you can do a custom one by registering a more specific
type:

```
@proxy(DecimalField)
class CustomDecimalFieldType
    ...

```

This will get picked up before the basic handler.


## Rendering approaches


### Communicate / stdin

Breaks with large data.
```
    process = subprocess.Popen(
        ["node", "./static/dist/server.js"],
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
    )
    print(data)
    process_response, error = process.communicate(data.encode())
```


### Threading
https://stackoverflow.com/a/14026178
Still breaks with large enough data.
```
    process = subprocess.Popen(
        ["node", "./static/dist/server.js"],
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
    )
    process_response = ""
    error = None

    def writer() -> None:
        for char in data:
            process.stdin.write(char.encode())
        process.stdin.close()

    thread = threading.Thread(target=writer)
    thread.start()
    for line in process.stdout:
        process_response += line.decode()
    thread.join()
    process.wait()
    assert False
```

### File based
This works, but seems kind of dirty and maybe problematic on docker images that
then grow in size.
```
    with tempfile.TemporaryFile() as buffer:
        buffer.write(data.encode())
        buffer.flush()
        buffer.seek(0)

        process = subprocess.Popen(
            ["node", "./static/dist/server.js"],
            stdout=subprocess.PIPE,
            stdin=buffer,
        )
        process_response, error = process.communicate()
```
